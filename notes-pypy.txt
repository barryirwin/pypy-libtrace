
1102, Mon 9 Nov 15 (NZDT)

Downloaded pypy OSX 64bit from pypy.org
Unpacked into /Users/jbro111/pypy
In /usr/local/bin
  sudo ln -s /Users/jbro111/pypy/pypy-4.0.0-osx64/bin/pypy pypy
Now pypy works from the command line

Copied plt stuff into ~/pypy
  mkdir lib
  cp -r ~/plt-svn/trunk/lib/* lib
Build ipp
  cd lib/ipp
  sudo pypy ipp-setup.py install
    lots of warnings, need to fix these <<<

  added  import cpyext  to test-ipp.py
    that crashes because pypy-26.so doesn't have _PyByteArray_AsString

in lib/ipp/ippmodule.c
  added defines for missing PyByteArray* functions, now compiles
    without warnings, but those functions aren't in ipp.pypy-26.so

cpyext seems difficult to add functions into.
It does allow your module (in Cpython) to 'just work' though.
It's possible that I only need to add some the missing
  PyByteArray functions - but it's not cler how to do that.

cffi allows you to write functions for your program in C.
That's fine for small chunks of C code, but it would probably mean
  rewriting plt in python!

1248, Tue 10 Nov 15 (NZDT)

nm is the command that lists entries in a library

libpypy-c.dylib is the library with the Python support functions

No, it looks as though redoing plt in (mostly) python using cffi
  will be the way to go, sigh.
Need to work out how to call libtrace functions from python first! <<<

Got a bit closer, need to be able to handle functions that return
  C pointers fo libtrace object, and use them to make a Python trace object.

0944, Wed 11 Nov 15 (NZDT)

https://github.com/wolever/python-cffi-example

cffi can't handle directives, need to remove them from libtrace.h
  Made lti.h (one line, #include "libtrace.h"
  gcc -E lti.h > lti-prep.h  # Expand all the #defines and #includes

  gcc -I/System/Library/Frameworks/Python.framework/Versions/2.7/include/python2.7 -c _libtrace.c
    builds _libtrace.o, but that doesn't help much

Promising, but ...

  cffi generates all sorts of glue stuff that seems to conflict with
  libtrace.h/lti-prep.h's effort to do the same.

No, Python.h #include <stdio.h> starts with #include <stddef.h>,
  that starts with #include <_types.h>, which gives conflicts
  with the same includes/defines in/from libtrace.h !!!

I think I'll need to make a new library of libtrace functions
with few defines (i.e. containing all the libtrace dependencies),
then call functions in that from cffi, sigh

Still, as long as they don't get called too often it will probably work!
Try it on ipp.so (which uses <arpa/inet.h> and some libc routines).

Did get build_tlt.py and try_tlt.py work calling trace_help();
then couldn't manage to declare struct libtrace_t

Thu, 12 Nov 15 (NZDT)

Discovered how to #include libtrace.h without strange interactions with
ffi, and how to create a C struct with cffi.

Worked through build_tlt_*.py and try-tlt-*.py versions 00 .. 05
05 has class trace that is able to read records from a trace object,
  and print them in hex :-)

Should try timing this (without printing), and compare it with a
  python2 version!

09909, Fri 13 Nov 15 (NZDT)

time python test-plt.py
real    0m1.883s
user    0m1.698s
sys     0m0.158s

time pypy test-pylt.py
real    0m0.594s
user    0m0.569s
sys     0m0.124s

=> pypy version about 3 times faster than python version!
Take out the fflush() call, about 2.5x faster.

Started on pypy/pylt/ipp:
  build-ipp.py and try-ipp running,
    class IPprefix now has __init()__ and __str__()
  i.e. we can create and print IPv4 and IPv6 prefixes,
  .version, .addr and .length work,
    except that addr returns a cdata uint8_t[16] or [4]

  Do we need to return ByteArray for prefix.addr?
    self.addr = ffi.new("uint8_t[16]", tuple(addr))  # Save addr ba as cdata
    self.addr[x], it returns an int !!
    
1113, Mon 16 Nov 15 (NZDT)

Tested whether cdata uint8_t can be used as a dictionary key - it can.
However, to print it one needs to know whether it's v4 or v6;
  lib.ipaddr2str() expects (version, addr)
=> IPprefixes used as keys should have None for their lengths!

Installed setuptools for pypy
  wget https://bitbucket.org/pypa/setuptools/raw/bootstrap/ez_setup.py -O - | pypy

Made ipp-setup.py to build _ipp module
 that all seems to work (now.)

Reworked it all so that:
  build-cipp.py has all the C stuff
  sudo pypy cipp-setup.py install  # installs it in a cipp module
  ipp.py has the python code (it imports cipp)
  sudo pypy ipp-setup.py install  # istalls the ipp module
Now try-ipp.py can use it all by just:  import ipp

Better still, in pylt/trace,
  try-trace.py  works properly!

1101, Tue 17 Nov 15 (NZDT)

Improved python code for IPprefix so as not to copy the addr cdata object.
Disadvantage - can't use a bytearray to create an IPprefix in python !!!

~/pypy/pylt/trace$ time pypy try-trace.py
EOF - - -
 2108363  109.105.114.14|163.7.160.3
 1607432  163.7.160.3|109.105.114.14
   34707  163.7.160.3|163.7.160.7
       1  163.7.160.3|202.6.116.123
       4  163.7.160.3|210.7.42.11
       1  163.7.160.3|91.189.89.199
   51999  163.7.160.7|163.7.160.3
       1  202.6.116.123|163.7.160.3
       4  210.7.42.11|163.7.160.3
     292  79.240.163.7|160.1.0.0
       1  91.189.89.199|163.7.160.3

real    0m4.279s
user    0m4.220s
sys     0m0.164s

~/pypy$ time python test-plt.py
EOF - - -
 2108363  109.105.114.14|163.7.160.3
 1607432  163.7.160.3|109.105.114.14
   34707  163.7.160.3|163.7.160.7
       1  163.7.160.3|202.6.116.123
       4  163.7.160.3|210.7.42.11
       1  163.7.160.3|91.189.89.199
   51999  163.7.160.7|163.7.160.3
       1  202.6.116.123|163.7.160.3
       4  210.7.42.11|163.7.160.3
       1  91.189.89.199|163.7.160.3

real    0m12.017s
user    0m11.577s
sys     0m0.143s

So, pypy is about 2.8 times faster :-)
without printing aything, it's about 2.7 times faster.

1428, Wed 18 Nov 15 (NZDT)

Implemented class ip as child of class packet, modified try-trtace
  to use it.  Works, but ip = pkt.ip redefines class ip as a new variable.
  _ip = pkt.ip is ok, but this error is hard to spot.
  Also, it doesn't happen in plt.

Realised than in plt, class packet attributes (ip, ip6, ...)
  all return DataObjects.  Their type is kept in the type, kind
  values.
That avoids naming clashes between variables and class names!

1028, Thu 19 Nov 15 (NZDT)

Ah, need to call the class something other than "ip", use _ip_obj.
Now, saving copy of packet as _ip_obj.pkt and using it there works,
  but refering to it through the packet superclass give a seg fault !@#$

1656, Fri 27 Nov 15 (NZDT)

All pkt attributes implemented in plt.py,
skeleton of internet, ip, udp and tcp also implemented.

Looked at .data, will be OK in _pkt_obj, but needs more work.
NOTE: instead of byte arrays, pypy ipp and plt use cdata uint8_t arrays.
  These can be indexed and iterated.
  What about using them as indeces to dictionaries??

In plt.py you can get ffi.buffer(ba) to get a ref to the array,
to make a copy use str(ffi.buffer(ba), can concatenate that with other ba's.

1752, Sat 28 Nov 15 (NZDT)

time pypy plt-test.py
real	0m11.514s
user	0m9.181s
sys	0m0.352s

Couldn't test python plt-test.py on Ubuntu, it tries to import plt,
then complains it can't find cplt - so the pypy plt has overwritten
the python one!

1032, Mon 29 Nov 15 (NZDT)

On OSX, made new 'pypy-test' directory for testing pypy plt,
  copied plt-test.py into it.

time python plt-test.py
real    0m16.868s
user    0m16.744s
sys     0m0.117s

In pypy/pylt/plt
time pypy plt-test.py
real    0m6.749s
user    0m6.208s
sys     0m0.210s

pypy ~ 2.5 times faster :)

1211, Thu  4 Dec 15 (NZDT)

Looking at using prefix.addr in dictionary keys:
p = ipp.Prefix("2345")
str(p.addr) -> "cdata 'uint8_t[]'  ... "
bpa = bytearray(sa.addr) # makes a bytearray

Improved ipp.IPprefix to check type of addr (args[1]),
  it now allows bytearray as well as cdata (assumes uint8_t[])

To use ipp.IPprefix in programs that import plt, can use
  plt.ipp.fn_name(), or (better)
  import plt, ipp  lets you use ipp.fn_name()

1510, Mon  7 Dec 15 (NZDT)

ipp complete, made new ipp-test.py program.

Worked on plt-test.py
  Made functions to build a key and split it into parts.
  However, it looks as though all the keys use pointers to the
  current packet (i.e. last one read) :-(

set_short and set_bytes allow one to build a key in a cdata uint8_t[],
  but that doesn't work as a dictionary key (probably because cdata
  doesn't have a hash function for such an array).
However, str(cdata array) does work correctly as a dictionary key.
  To unpack a key string, convert it to bytearray, then use
  ipp.IPprefix() on key prefix, and get_short() on port numbers.

1705, Mon 14 Dec 2015 (NZDT)

ip and ip6 done, checksumd (in cplt.py) finally sorted!

Working on plt.new(object)  object nad by cdata or bytearray:
  Need to implement mom; not used in struct pi - simplest way
  seems to be to have mom as python object in all objects.

1650, Tue 15 Dec 2015 (NZDT)

tcp and udp completed.  Testing tcp revealed that .payload for
  ip/ip6/tcp/udp returns a cdata slice, but the C-API version
  returned a data object!
In python we implelemented .data in _pkt_obj, returning
  a byte array built from l2p,l2_rem for TYPE_PKT, or
  dp,rem for anything else.
For pypy, we can return the cdata slice, but for that to work
  we need to return an object, i.e. a (pi, mom) tuple

1157, Wed 16 Dec 2015 (NZDT)

Implemented get_payload for tcp and udp, returning (pi, nom)
for a TYPE_L5 object.
ip, ip6, tcp and udp now all work (with the plt_testing.py module)

1140, Fri 18 Dec 2015 (NZDT)

Bug in libtrace 3.0.22: trace_get_payload_from_vlan() doesn't subtract
  4 from rem to allow for the vlan header!

Finished layers, started on pldns.  Need to add stuff for rr and rr lists

1734, Fri  1 Jan 2016 (NzDT)

test-IPflow.py doesn't work, fkey4 doesn't make a proper dictionary key.
Above,  str(cdata array) did work - try making a C function to return
a "uint8_t []" to make a flow key

1712, Sat  3 Jan 2016 (NZDT)

  fk = ffi.cast("uint8_t[14]", fkey)
  return str(bytearray(fk))
works properly; there doesn't seem to be a way to make a python string
directly, sigh

1303, Mon  4 Jan 2015 (NZDT)

Ah, return(str(ffi.buffer(self.fkey))) is the right way to do this :-)

Changed natkit.py (get_short, get_long) and plt.py (mk_data) so as
  not to use ffi.new(uint8_t[%d] % len())
  Tested using test-u32.py, icmp.py and icmp6.py

Note that IPflow() returns None if it the flow is not IP/IP6
  or not TCP/UDP (don't need to use try/except for these) <<<<<

1545, Tue  5 Jan 2015 (NZDT)

Implemented HomeFLow & friends; flow() is a class function of class HomeFlow
( natkit.IPflow(pkt_object) is how one creates an IPflow )

is_inward property was wrongly documented - it's true if one and ony one
  of it's saddr and daddr are in a home network.  Correct the .html doc
  Can we think of a better name for this?  cross_border?

Changed the copyright notices to 2016 (from 2014 and 2015)

1513, Wed  6 Jan 2016 (NZDT)

time python ./tcp-analyse.py -p5001 -a'5:9' fdt-p5.pcap
Total of 20.031 GB transferred, last_t = 193.090
Average transfer rate = 0.830 Gb/s

real    0m52.712s
user    0m51.832s
sys     0m0.387s

time pypy ./tcp-analyse.py -p5001 -a'5:9' fdt-p5.pcap
Total of 20.031 GB transferred, last_t = 193.090
Average transfer rate = 0.830 Gb/s

real    0m12.615s
user    0m12.163s
sys     0m0.333s

About 4x speedup :-)

1534, Thu 14 Jan 2016 (NZDT)

Made new directory: pypy-libtrace
  moved all the pypy libtrace stuff into it, with subdirectories
    lib / ipp, plt, pldns, natkit
    examples and examples/traces
  Problems with exclude-list.txt, reworked that (*gz works in subdirs)
Made new Makefile,
  can sudo make ipp|plt|pldns|natkit to rebuild and install parts
  make install makes and installs everything

Need to make a clean set of test files in testing subdir <<<

To install pypy-libtrace

- install libtrace
- install pypy, cffi
    download from http://pypy.org/download.html
    unpack, make symbolic link
      cd /usr/local/bin
      sudo ln -s /home/jbro111/pypy/pypy-4.0.1-linux64/bin/pypy pypy
    cffi is included as part of pypy
- install setuptools
    wget https://bitbucket.org/pypa/setuptools/raw/bootstrap/ez_setup.py -O - | pypy
    didn't work on nevil-res4.its:
      ran wget on OSX, to get setuptools-19.2.zip nevil
      scp that to nevil-res4
      unzip setuptools-19.2.zip 
      cd setuptools-19.2/
      pypy setup.py install

tried cd ~/pypy-libtrace/lib/natkit, pypy test-IPflow.py
  had to change trace dir to ../../examples/traces
  then it ran as expected

1228, Fri 15 Jan 2016 (NZDT)

Chat with wannes, OK to use github for pypy-libtrace, note that
  others can clone a copy and work on that!
Also OK to copy Habib's testing system into pypy-libtrace.

1650, Wed 20 Jan 2016 (NZDT)

Reached the last test program, text-v6-tunnel.py
That fails to get proto right;
  For a packet (i.e. inside _pkt_obj), trace_get_transport() works fine
  but for a data array (a bare Cdata array), we need to use
    trace_get_payload_form_ip6() in get_transport_info(), sigh

1003, Thu 21 Jan 2016 (NZDT)

Added get_ip6_proto() in build-cplt.py, use when we don't have a packet,
  e.g. for an ip6(data).

In build-cplt.py, three functions set pi.proto:
  get_ip6_proto() - in _inet_obj.get_proto
  get_transport_info() - in _pkt_obj.get_transport
  get_trans_payload()  - pkt.get_ tcp/udp/icmp/icmp6 and their _payloads

mk_new_obj() needs to set proto correctly, added code to do that.

The only place where we need to get the transport protocol
  other than in tcp/udp/etc is in _inet_obj.proto
We used to do that by calling get_trans_payload(),
  now we get it from the IP header (v4) or using get_ip6_proto()

test-v6-tunnel.py creates an _ip6_obj, then tries to get ip6.udp.
But .udp is in _pkt_obj, so it thinks the object should be kind == pkt.
All it really needs is that its l3_rem should be > 0,
  call check_obj)ip() to do that in get_tcp/udp/etc

1243, Fri 22 Jan 2016 (NZDT)

Tried pypy-test-cases using python v2, 9 failed!
   1. test-checksum.py   OK, set_chcecksums returns None if it can't,
      			   instead of raising an exception "Too short to set"
   2. test-checksum6.py  OK, test_l3_cksm returns None for "Too short"
   3. test-HomeFlow.py   OK, 4 lines added into source file
   4. test-icmp.py       OK, pypy version hexprints Echo[0:16]
   5. test-IPflow.py     OK, python rises "Not an IP packet"
      			   Fix this, return None instead <<<<<
   6. test-ipp.py        OK, width( = length-1) was a method in python-libtrace
   7. test-layers.py     OK, pypy-lt gives actual object types
   8. test-plt.py        OK, version changed from 1.8 to 2.0
   9. test-read.py       OK, pypy-lt hexprints Echo data

Fixed IPflow/not IP, removed class/__new__ from natkit and pldns

Installing pypy:
  Get right version from pypy.org
    uname -m # x86_64 = 64-bit
    Tried  pypy-4.0.1-linux_x86_64-portable.tar.bz2 on nevil-res4.its
    Read 'Installing' on pypy.org download page:
      install setup
      sudo ln -s /home/jbro111/pypy/pypy-4.0.1-linux64/bin/pypy pypy
  Install setuptools
      wget https://bitbucket.org/pypa/setuptools/raw/bootstrap/ez_setup.py -O - | pypy
    didn't work on nevil-res4.its:
      ran wget on OSX, to get setuptools-19.2.zip nevil
      scp that to nevil-res4
      unzip setuptools-19.2.zip 
      cd setuptools-19.2/
      pypy setup.py install




