# 1053, Tue 22 Dec 2015 (NZDT)
#
# natkit.py:  natkit objects iplemented in python
#
# Copyright (C) 2015 by Nevil Brownlee, U Auckland | WAND
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


from cnatkit import ffi, lib
from cplt import lib as plt_lib
import ipp, plt


def ba_get_short(bp, x):
    if isinstance(bp, ffi.CData):
        if x+2 > ffi.sizeof(bp):
            return None
        return plt.get_short(bp, x)
    elif isinstance(bp, bytearray):
        if x+2 > len(bp):
            return None
        data = ffi.new("uint8_t[]", tuple(bp))
        return plt.get_short(data, x)
    raise TypeError("Expected 'cdata uint8_t[]' or bytearray!")

def ba_get_long(bp, x):
    if isinstance(bp, ffi.CData):
        if x+4 > ffi.sizeof(bp):
            return None
        return plt.get_long(bp, x)
    elif isinstance(bp, bytearray):
        if x+4 > len(bp):
            return None
        data = ffi.new("uint8_t[]", tuple(bp))
        return plt.get_long(data, x)
    raise TypeError("Expected 'cdata uint8_t[]' or bytearray!")


def seq_add(a, b):
    return lib.seq_add(a, b)

def seq_sub(a, b):
    return lib.seq_sub(a, b)

def seq_lt(a, b):
    return bool(lib.seq_lt(a, b))

def seq_ge(a, b):
    return bool(lib.seq_ge(a, b))

def seq_gt(a, b):
    return bool(lib.seq_gt(a, b))


FT_FIRST_PKT = 0  # Default, first pkt src->dst
FT_HOME_FLOW = 1

class _IPflow_obj(object):
    def __init__(self, fkey):
        self.fkey = fkey

    def get_version(self):
        return self.fkey.version
    version = property(get_version)
        
    def get_proto(self):
        return self.fkey.proto
    proto = property(get_proto)
        
    def get_src_port(self):
        return plt.lib.get_short(self.fkey.sport, 0)
    src_port = property(get_src_port)
        
    def get_dst_port(self):
        return plt.lib.get_short(self.fkey.dport, 0)
    dst_port = property(get_dst_port)
        
    def get_src_prefix(self):
        return ipp.IPprefix(self.fkey.version, self.fkey.saddr)
    src_prefix = property(get_src_prefix)
        
    def get_dst_prefix(self):
        return ipp.IPprefix(self.fkey.version, self.fkey.daddr)
    dst_prefix = property(get_dst_prefix)
        
    def get_fwd_key(self):
        #fk = ffi.cast("uint8_t[14]", self.fkey)
        #return str(bytearray(fk))
        return(str(ffi.buffer(self.fkey)))
    fwd_key = property(get_fwd_key)
        
    def get_rev_key(self):
        if self.fkey.version == 4:
            rkey = ffi.new("struct fkey4 *");  alen = 4
        else:
            rkey = ffi.new("struct fkey6 *");  alen = 16
        rkey.version = self.fkey.version
        rkey.proto = self.fkey.proto
        ffi.memmove(rkey.sport, self.fkey.dport, 2)
        ffi.memmove(rkey.dport, self.fkey.sport, 2)
        ffi.memmove(rkey.saddr, self.fkey.daddr, alen)
        ffi.memmove(rkey.daddr, self.fkey.saddr, alen)
        #rk = ffi.cast("uint8_t[14]", rkey)
        #return str(bytearray(rk))
        #return rkey
        return(str(ffi.buffer(rkey)))
    rev_key = property(get_rev_key)
        

class IPflow(_IPflow_obj):
    def __new__(cls, obj):  # Make IPflow from plt object
        # plt.Data_dump(obj.pi, None, "starting IPflow.__new__")
        if obj.pi.o_kind != plt.KIND_PKT:
            raise PltError("Object didn't come from a plt Packet")
        #self.flow_type = FT_FIRST_PKT
        if obj.pi.proto == 0:
            new_pi = plt.ffi.new("struct pi *")
            if not bool(plt_lib.get_transport_info(new_pi, obj.pi)):
                return None
            pi = new_pi
        if pi.proto != 6 and pi.proto != 17:
            return None  # Only handle TCP and UDP for now
        version = 4
        if pi.ethertype == 0x0800:
            fkey = ffi.new("struct fkey4 *")
            fkey.version = 4
            ffi.memmove(fkey.saddr, pi.l3p[12:16], 4)
            ffi.memmove(fkey.daddr, pi.l3p[16:20], 4)
        else:
            fkey = ffi.new("struct fkey6 *")
            fkey.version = 6;
            ffi.memmove(fkey.saddr, pi.l3p[8:24], 16)
            ffi.memmove(fkey.daddr, pi.l3p[24:40], 16)
        fkey.proto = pi.proto
        ffi.memmove(fkey.sport, pi.dp[0:2], 2)
        ffi.memmove(fkey.dport, pi.dp[2:4], 2)

        #alen = 4
        #if fkey.version == 6:
        #    alen = 16
        #klen = 6+2*alen
        #bkey = ffi.new("uint8_t[]", klen)  # Don't use ([%d], klen) !
        #ffi.memmove(bkey, fkey, klen)
        #print "!!! bkey = %s" % bkey
        #plt.print_cdata(bkey, klen)
        return _IPflow_obj(fkey)
            

class HomeFlow(object):
    pass


class Flow(object):
    pass
